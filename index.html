<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Greece Official Disaster Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root {
      --bg:#101820;
      --panel:#121c26;
      --muted:#8aa0b2;
      --text:#e8f0f6;
      --green:#3dd87e;
      --red:#ff5c5c;
      --accent:#3aa0ff;
    }
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:var(--bg); color:var(--text); }
    #app { display:flex; height:100%; }
    #sidebar {
      width:260px; min-width:260px; max-width:320px;
      background:var(--panel); padding:12px 12px 16px; box-sizing:border-box; overflow:auto; border-right:1px solid #0b141c;
    }
    #map { flex:1; }
    h1 { font-size:16px; margin:4px 0 6px; }
    .sub { font-size:12px; color:var(--muted); line-height:1.35; margin-bottom:10px; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px; }
    .card {
      background:#0e1821; border:1px solid #0b141c; border-radius:8px; padding:8px;
    }
    .k { font-size:12px; color:var(--muted); }
    .v { font-size:20px; font-weight:700; margin-top:2px; }
    .row { display:flex; align-items:center; gap:8px; margin:8px 0; }
    .muted { color:var(--muted); font-size:12px; }
    .controls label { font-size:13px; margin-right:8px; }
    select, button {
      background:#0a141c; color:var(--text); border:1px solid #0b141c; border-radius:6px; padding:6px 8px; font-size:13px;
    }
    button { cursor:pointer; }
    .legend { font-size:12px; color:var(--muted); margin-top:10px; }
    .status-dot { width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:6px; }
    .ok { background:var(--green); } .err { background:var(--red); }
    .updated { font-size:12px; color:var(--muted); }
    .divider { height:1px; background:#0b141c; margin:10px 0; }

    /* Leaflet tweaks (better for dark background) */
    .leaflet-control-zoom a { background:#0a141c; color:#fff; border:none; }
    .leaflet-control-zoom a:hover { background:#13202b; }
  </style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h1>Greece Official Disaster Map</h1>
    <div class="sub">Live earthquakes and fires in Greece. Data refreshes automatically every 10 minutes.</div>

    <div class="grid">
      <div class="card">
        <div class="k">Earthquakes</div>
        <div class="v" id="stat-quakes">0</div>
      </div>
      <div class="card">
        <div class="k">Fires</div>
        <div class="v" id="stat-fires">0</div>
      </div>
      <div class="card" style="grid-column:1 / span 2;">
        <div class="k">Total</div>
        <div class="v" id="stat-total">0</div>
      </div>
    </div>

    <div class="row updated">Last updated: <span id="last-updated">—</span></div>

    <div class="divider"></div>

    <div class="controls">
      <div class="row">
        <label><input type="checkbox" id="show-quakes" checked /> Earthquakes</label>
        <label><input type="checkbox" id="show-fires" checked /> Fires</label>
      </div>

      <div class="row">
        <select id="timeRange" title="Time period (affects both)">
          <option value="1">24 hours</option>
          <option value="3">3 days</option>
          <option value="7" selected>7 days</option>
          <option value="30">30 days</option>
          <option value="90">3 months</option>
          <option value="365">Last year</option>
        </select>

        <select id="minMag" title="Minimum earthquake magnitude">
          <option value="2">M 2+</option>
          <option value="3" selected>M 3+</option>
          <option value="4">M 4+</option>
          <option value="5">M 5+</option>
        </select>

        <button id="btn-refresh">Refresh</button>
      </div>
    </div>

    <div class="divider"></div>

    <div class="legend">
      <div><span class="status-dot ok"></span>API reachable</div>
      <div><span class="status-dot err"></span>API error</div>
      <div style="margin-top:8px;">
        • Earthquakes API • Fires API
      </div>
      <div style="margin-top:8px;">© Live, client-side map. Built with Leaflet.</div>
    </div>
  </aside>

  <div id="map"></div>
</div>

<script>
  // ================== CONFIG ==================
  // Your Worker base URL (no trailing slash)
  const API_BASE = 'https://greece-disasters.odysseas-3d2.workers.dev';

  // Greece bbox for Leaflet fit
  const GRC_BBOX = { south:34.8, north:41.8, west:19.3, east:29.6 };
  // ============================================

  // Map
  const map = L.map('map', { zoomSnap: 0.25 });
  const center = [(GRC_BBOX.south + GRC_BBOX.north)/2, (GRC_BBOX.west + GRC_BBOX.east)/2];
  map.setView(center, 6.25);

  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const quakesLayer = L.layerGroup().addTo(map);
  const firesLayer  = L.layerGroup().addTo(map);

  // UI
  const $ = sel => document.querySelector(sel);
  const statQuakes = $('#stat-quakes');
  const statFires  = $('#stat-fires');
  const statTotal  = $('#stat-total');
  const lastUpdated = $('#last-updated');

  // Inputs
  const showQuakes = $('#show-quakes');
  const showFires  = $('#show-fires');
  const timeRange  = $('#timeRange');
  const minMagSel  = $('#minMag');
  const btnRefresh = $('#btn-refresh');

  showQuakes.addEventListener('change', () => { quakesLayer.clearLayers(); drawQuakes(_quakesFiltered); if (!showQuakes.checked) quakesLayer.clearLayers(); });
  showFires.addEventListener('change',  () => { firesLayer.clearLayers();  drawFires(_firesFiltered);   if (!showFires.checked)  firesLayer.clearLayers();  });

  timeRange.addEventListener('change', () => refresh(true));
  minMagSel.addEventListener('change', () => refresh(true));
  btnRefresh.addEventListener('click', () => refresh(true));

  // Data caches (in-memory)
  let _quakesRaw = [], _firesRaw = [];
  let _quakesFiltered = [], _firesFiltered = [];

  function toMs(t) {
    // Worker may return number (ms) or ISO string; normalize
    if (typeof t === 'number') return t;
    const parsed = Date.parse(t);
    return Number.isFinite(parsed) ? parsed : 0;
  }

  function cutoffMs(days) {
    return Date.now() - Number(days) * 24 * 60 * 60 * 1000;
  }

  function withinGreece(lat, lon) {
    return lat >= GRC_BBOX.south && lat <= GRC_BBOX.north && lon >= GRC_BBOX.west && lon <= GRC_BBOX.east;
  }

  async function fetchJSON(url) {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  function fmtTime(ms) {
    const d = new Date(ms);
    return d.toLocaleString([], { hour12:false });
  }

  function quakeColor(m) {
    // yellow -> red scale
    const clamped = Math.max(2, Math.min(6.5, m || 0));
    const t = (clamped - 2) / 4.5; // 0..1
    const r = Math.round(255 * t);
    const g = Math.round(200 * (1 - t) + 40 * t);
    return `rgb(${r},${g},0)`;
  }

  function quakeRadius(m) {
    // perceptual-ish
    return 3 + Math.pow(Math.max(0, m), 1.8);
  }

  function fireColor(verified) {
    return verified ? '#ff3b3b' : '#ffb347';
  }

  function fireRadius(brightness) {
    const b = Number(brightness) || 0;
    return 3 + Math.min(10, (b - 300) / 8); // small tweak
  }

  function updateStats() {
    const q = _quakesFiltered.length;
    const f = _firesFiltered.length;
    statQuakes.textContent = q.toLocaleString();
    statFires.textContent  = f.toLocaleString();
    statTotal.textContent  = (q + f).toLocaleString();
    lastUpdated.textContent = new Date().toLocaleTimeString([], { hour12:false });
  }

  function drawQuakes(quakes) {
    if (!showQuakes.checked) return;
    for (const e of quakes) {
      const lat = e.lat, lon = e.lon;
      if (!withinGreece(lat, lon)) continue;

      const mag = Number(e.mag) || 0;
      const color = quakeColor(mag);
      const radius = quakeRadius(mag);

      const marker = L.circleMarker([lat, lon], {
        radius, color, weight:1, fillColor: color, fillOpacity:0.6
      });

      const timeMs = toMs(e.time);
      const place = e.place || '—';
      const depth = (e.depth ?? '—');
      const srcs  = Array.isArray(e.sources) ? e.sources.join(', ') : (e._src || '—');
      const link  = e.url ? `<br/><a href="${e.url}" target="_blank" rel="noopener">details</a>` : '';

      marker.bindPopup(
        `<b>Magnitude:</b> M ${mag.toFixed(1)}<br/>
         <b>Depth:</b> ${depth} km<br/>
         <b>Time:</b> ${fmtTime(timeMs)}<br/>
         <b>Place:</b> ${place}<br/>
         <b>Sources:</b> ${srcs}${link}`
      );
      marker.addTo(quakesLayer);
    }
  }

  function drawFires(fires) {
    if (!showFires.checked) return;
    for (const f of fires) {
      const lat = f.lat, lon = f.lon;
      if (!withinGreece(lat, lon)) continue;

      const color = fireColor(!!f.verified);
      const radius = Math.max(3, fireRadius(f.brightness));

      const marker = L.circleMarker([lat, lon], {
        radius, color, weight:1, fillColor: color, fillOpacity:0.6
      });

      const timeMs = toMs(f.time);
      const srcs = Array.isArray(f.sources) ? f.sources.join(', ') : (f._src || '—');

      marker.bindPopup(
        `<b>Brightness:</b> ${f.brightness ?? '—'}<br/>
         <b>Confidence:</b> ${f.confidence ?? '—'}<br/>
         <b>Time:</b> ${fmtTime(timeMs)}<br/>
         <b>Sources:</b> ${srcs}${f.satellite ? `<br/><b>Sat:</b> ${f.satellite}`:''}`
      );
      marker.addTo(firesLayer);
    }
  }

  function applyFilters() {
    const days = Number(timeRange.value);
    const minMag = Number(minMagSel.value);
    const cutoff = cutoffMs(days);

    _quakesFiltered = _quakesRaw.filter(e => {
      const t = toMs(e.time);
      const m = Number(e.mag) || 0;
      return t >= cutoff && m >= minMag;
    });

    _firesFiltered = _firesRaw.filter(f => toMs(f.time) >= cutoff);

    quakesLayer.clearLayers();
    firesLayer.clearLayers();
    drawQuakes(_quakesFiltered);
    drawFires(_firesFiltered);
    updateStats();
  }

  async function refresh(force = false) {
    const days = Number(timeRange.value);
    const minMag = Number(minMagSel.value);

    // Build URLs with explicit params so time range ALWAYS flows through.
    // Adding a small cache-buster when "force" to bypass any browser cache layer.
    const buster = force ? `&t=${Date.now()}` : '';
    const quakesUrl = `${API_BASE}/api/earthquakes?days=${days}&minMag=${minMag}${buster}`;
    const firesUrl  = `${API_BASE}/api/fires?days=${days}${buster}`;

    try {
      const [q, f] = await Promise.all([
        fetchJSON(quakesUrl),
        fetchJSON(firesUrl)
      ]);

      // Worker payloads: { ok, count, data:[...] }
      _quakesRaw = Array.isArray(q?.data) ? q.data : [];
      _firesRaw  = Array.isArray(f?.data) ? f.data : [];

      applyFilters(); // client-side cutoff too (defensive & instant UI)
    } catch (err) {
      console.error('Fetch error:', err);
      // Keep existing layers, but update timestamp so you see an attempt happened
      lastUpdated.textContent = new Date().toLocaleTimeString([], { hour12:false });
    }
  }

  // Initial load + auto-refresh every 10 minutes
  refresh(true);
  setInterval(() => refresh(false), 10 * 60 * 1000);

  // Fit bounds to Greece on first interaction
  map.fitBounds([[GRC_BBOX.south, GRC_BBOX.west],[GRC_BBOX.north, GRC_BBOX.east]]);
</script>
</body>
</html>
